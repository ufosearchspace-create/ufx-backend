# Workflow: create-auth-pr.yml
# Run manually (workflow_dispatch). It will:
# - checkout main
# - create branch feature/auth-gate
# - create src/routes/auth.js with the provided content
# - prepend import of authRouter to server.js and insert app.use('/api/auth', authRouter)
# - add ethers to package.json dependencies (via node)
# - commit, push and open a PR using peter-evans/create-pull-request
name: Create auth-gate PR

on:
  workflow_dispatch:

permissions:
  contents: write  # needed to push branch and create PR
  pull-requests: write

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create feature branch
        run: |
          git switch -c feature/auth-gate

      - name: Create src/routes/auth.js
        run: |
          mkdir -p src/routes
          cat > src/routes/auth.js <<'EOF'
import express from 'express';
import { supabase } from '../supabase.js';
import { ethers } from 'ethers';

const router = express.Router();

const WHITELIST_TABLE = process.env.SUPABASE_WHITELIST_TABLE || 'whitelisted_wallets';
const WHITELIST_ADDRESS_COL = process.env.SUPABASE_WHITELIST_ADDRESS_COL || 'wallet_address';
const WHITELIST_FLAG_COL = process.env.SUPABASE_WHITELIST_FLAG_COL || 'active';
const DEFAULT_MIN_TOKEN = Number(process.env.MIN_TOKEN_AMOUNT || 1);

function normalizeAddress(addr) {
  if (!addr) return null;
  return addr.trim().toLowerCase();
}

// Accepts POST (JSON body) and GET (query param) for quick tests
router.all('/check-access', async (req, res) => {
  try {
    const body = req.method === 'GET' ? req.query : req.body || {};
    const rawAddress = body.address;
    if (!rawAddress) return res.status(400).json({ success: false, error: 'address required' });

    const address = normalizeAddress(rawAddress);
    if (!address) return res.status(400).json({ success: false, error: 'invalid address' });

    // Server-side whitelist check using service role supabase client
    const { data: rows, error: supErr } = await supabase
      .from(WHITELIST_TABLE)
      .select(WHITELIST_FLAG_COL)
      .eq(WHITELIST_ADDRESS_COL, address)
      .limit(1);

    if (supErr) {
      console.error('Supabase whitelist error:', supErr);
      return res.status(500).json({ success: false, error: 'supabase_error' });
    }

    const whitelisted = Array.isArray(rows) && rows.length > 0 && !!rows[0][WHITELIST_FLAG_COL];

    // If token gating not configured, return whitelist result
    const tokenContract = body.tokenContract || process.env.TOKEN_CONTRACT_ADDRESS || null;
    const minAmount = Number(body.minAmount ?? process.env.MIN_TOKEN_AMOUNT ?? DEFAULT_MIN_TOKEN);

    if (!tokenContract) {
      return res.json({
        success: true,
        allowed: whitelisted,
        reason: whitelisted ? 'whitelist' : 'not_whitelisted'
      });
    }

    // Token gating path: attempt on-chain check (ERC-20)
    try {
      const rpc = process.env.BASE_RPC_URL || process.env.NEXT_PUBLIC_BASE_RPC_URL;
      if (!rpc) {
        // No RPC configured - fallback to whitelist
        return res.json({
          success: true,
          allowed: whitelisted,
          reason: whitelisted ? 'whitelist_fallback_no_rpc' : 'no_rpc_and_not_whitelisted'
        });
      }

      const provider = new ethers.JsonRpcProvider(rpc);
      const abi = [
        'function balanceOf(address owner) view returns (uint256)',
        'function decimals() view returns (uint8)'
      ];
      const contract = new ethers.Contract(tokenContract, abi, provider);

      const [rawBalance, decimals] = await Promise.all([
        contract.balanceOf(address),
        contract.decimals().catch(() => 18)
      ]);

      const human = Number(ethers.formatUnits(rawBalance, decimals));
      const allowed = human >= minAmount;

      return res.json({
        success: true,
        allowed,
        reason: allowed ? 'token_balance' : (whitelisted ? 'whitelist_override' : 'insufficient_balance'),
        balance: human
      });
    } catch (err) {
      console.warn('On-chain balance check failed:', err?.message || err);
      // Fallback to whitelist result on error
      return res.json({
        success: true,
        allowed: whitelisted,
        reason: whitelisted ? 'whitelist_fallback_onchain_error' : 'onchain_error_and_not_whitelisted'
      });
    }
  } catch (err) {
    console.error('POST /api/auth/check-access error:', err);
    return res.status(500).json({ success: false, error: String(err?.message || err) });
  }
});

export default router;
EOF

      - name: Inject import into server.js (prepend import line)
        run: |
          # Prepend import line if not present
          if ! grep -q "import authRouter from './src/routes/auth.js';" server.js; then
            (echo "import authRouter from './src/routes/auth.js';"; cat server.js) > server.tmp && mv server.tmp server.js
          else
            echo "authRouter import already present"
          fi

      - name: Insert app.use('/api/auth', authRouter) before error handler
        run: |
          if grep -q "app.use('/api/auth', authRouter);" server.js; then
            echo "auth route already registered"
          else
            # Insert the app.use line before the error handler middleware (looks for 'app.use((err, req, res, next) => {')
            awk 'BEGIN{inserted=0}
              /app.use\(\(err, req, res, next\) =>/ && !inserted {
                print "app.use(\\047/api/auth\\047, authRouter);"
                inserted=1
              }
              {print}
              END{ if(!inserted) { print "\\n// If error handler pattern not found, app.use(\\047/api/auth\\047, authRouter); was not auto-inserted. Please add it manually." } }' server.js > server.new && mv server.new server.js
          fi

      - name: Add ethers dependency to package.json
        run: |
          node -e "
          const fs = require('fs');
          const p = JSON.parse(fs.readFileSync('package.json').toString());
          p.dependencies = p.dependencies || {};
          if(!p.dependencies['ethers']){
            p.dependencies['ethers']='^6.9.0';
            fs.writeFileSync('package.json', JSON.stringify(p, null, 2));
            console.log('ethers added');
          } else {
            console.log('ethers already present');
          }
          "
      - name: Install (update) package-lock.json
        run: |
          npm ci --package-lock-only
      - name: Commit & push changes
        run: |
          git add src/routes/auth.js server.js package.json package-lock.json || true
          git commit -m "Add src/routes/auth.js (implement auth check endpoint)" -m "Register auth route in server.js" -m "Add ethers dependency to package.json" || true
          git push --set-upstream origin feature/auth-gate

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Add server-side auth route for whitelist token gating"
          branch: feature/auth-gate
          base: main
          title: "Add server-side auth route for whitelist token gating"
          body: |
            Add server-side auth route for whitelist token gating

            Što je dodano:
            - src/routes/auth.js: nova ruta /api/auth/check-access (POST + GET). Provjerava tablicu whitelisted_wallets (ili drugo ime prema env var) koristeći SUPABASE_SERVICE_ROLE_KEY server-side i vraća JSON { success, allowed, reason, balance? }.
            - server.js: automatski injektiran import authRouter i registracija app.use('/api/auth', authRouter).
            - package.json: dodana dependency "ethers" za eventualne on-chain provjere.

            IMPORTANT environment variables to set on Render (backend):
            - SUPABASE_URL
            - SUPABASE_SERVICE_ROLE_KEY
            - SUPABASE_WHITELIST_TABLE = whitelisted_wallets
            - SUPABASE_WHITELIST_ADDRESS_COL = wallet_address
            - SUPABASE_WHITELIST_FLAG_COL = active
            - BASE_RPC_URL (optional; for on-chain checks)
            - TOKEN_CONTRACT_ADDRESS + MIN_TOKEN_AMOUNT (optional; when token is deployed)

            Manual test (after redeploy):
            - curl https://<backend-url>/health
            - curl -X POST https://<backend-url>/api/auth/check-access -H "Content-Type: application/json" -d '{"address":"0x..."}'

            Security note:
            - Supabase service_role key is only used server-side in the backend.
            - The action uses the repository's GITHUB_TOKEN to push and open the PR.

            Screenshots/context: user provided Supabase and Vercel screenshots.

            DO NOT MERGE until reviewed and tested.
