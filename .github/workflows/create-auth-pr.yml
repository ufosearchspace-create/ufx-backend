# Create auth-gate PR (manual run; uses GitHub API to avoid YAML here-doc issues)
name: Create auth-gate PR

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  create-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch feature/auth-gate
        run: |
          git switch -c feature/auth-gate

      - name: Create/Update files via GitHub API
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');

            // AUTH.JS content
            const authContent = `import express from 'express';
import { supabase } from '../supabase.js';
import { ethers } from 'ethers';

const router = express.Router();

const WHITELIST_TABLE = process.env.SUPABASE_WHITELIST_TABLE || 'whitelisted_wallets';
const WHITELIST_ADDRESS_COL = process.env.SUPABASE_WHITELIST_ADDRESS_COL || 'wallet_address';
const WHITELIST_FLAG_COL = process.env.SUPABASE_WHITELIST_FLAG_COL || 'active';
const DEFAULT_MIN_TOKEN = Number(process.env.MIN_TOKEN_AMOUNT || 1);

function normalizeAddress(addr) {
  if (!addr) return null;
  return addr.trim().toLowerCase();
}

// Accepts POST (JSON body) and GET (query param) for quick tests
router.all('/check-access', async (req, res) => {
  try {
    const body = req.method === 'GET' ? req.query : req.body || {};
    const rawAddress = body.address;
    if (!rawAddress) return res.status(400).json({ success: false, error: 'address required' });

    const address = normalizeAddress(rawAddress);
    if (!address) return res.status(400).json({ success: false, error: 'invalid address' });

    // Server-side whitelist check using service role supabase client
    const { data: rows, error: supErr } = await supabase
      .from(WHITELIST_TABLE)
      .select(WHITELIST_FLAG_COL)
      .eq(WHITELIST_ADDRESS_COL, address)
      .limit(1);

    if (supErr) {
      console.error('Supabase whitelist error:', supErr);
      return res.status(500).json({ success: false, error: 'supabase_error' });
    }

    const whitelisted = Array.isArray(rows) && rows.length > 0 && !!rows[0][WHITELIST_FLAG_COL];

    // If token gating not configured, return whitelist result
    const tokenContract = body.tokenContract || process.env.TOKEN_CONTRACT_ADDRESS || null;
    const minAmount = Number(body.minAmount ?? process.env.MIN_TOKEN_AMOUNT ?? DEFAULT_MIN_TOKEN);

    if (!tokenContract) {
      return res.json({
        success: true,
        allowed: whitelisted,
        reason: whitelisted ? 'whitelist' : 'not_whitelisted'
      });
    }

    // Token gating path: attempt on-chain check (ERC-20)
    try {
      const rpc = process.env.BASE_RPC_URL || process.env.NEXT_PUBLIC_BASE_RPC_URL;
      if (!rpc) {
        // No RPC configured - fallback to whitelist
        return res.json({
          success: true,
          allowed: whitelisted,
          reason: whitelisted ? 'whitelist_fallback_no_rpc' : 'no_rpc_and_not_whitelisted'
        });
      }

      const provider = new ethers.JsonRpcProvider(rpc);
      const abi = [
        'function balanceOf(address owner) view returns (uint256)',
        'function decimals() view returns (uint8)'
      ];
      const contract = new ethers.Contract(tokenContract, abi, provider);

      const [rawBalance, decimals] = await Promise.all([
        contract.balanceOf(address),
        contract.decimals().catch(() => 18)
      ]);

      const human = Number(ethers.formatUnits(rawBalance, decimals));
      const allowed = human >= minAmount;

      return res.json({
        success: true,
        allowed,
        reason: allowed ? 'token_balance' : (whitelisted ? 'whitelist_override' : 'insufficient_balance'),
        balance: human
      });
    } catch (err) {
      console.warn('On-chain balance check failed:', err?.message || err);
      // Fallback to whitelist result on error
      return res.json({
        success: true,
        allowed: whitelisted,
        reason: whitelisted ? 'whitelist_fallback_onchain_error' : 'onchain_error_and_not_whitelisted'
      });
    }
  } catch (err) {
    console.error('POST /api/auth/check-access error:', err);
    return res.status(500).json({ success: false, error: String(err?.message || err) });
  }
});

export default router;
`;

            // READ current server.js
            const serverPath = 'server.js';
            const pkgPath = 'package.json';

            // Helper to create/update a file on the feature branch
            async function createOrUpdate(path, content, message) {
              const { data: current } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path,
                ref: 'main'
              }).catch(() => ({ data: null }));

              const encoded = Buffer.from(content).toString('base64');

              if (current && current.sha) {
                // update on new branch
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path,
                  message,
                  content: encoded,
                  sha: current.sha,
                  branch: 'feature/auth-gate'
                });
              } else {
                await github.rest.repos.createOrUpdateFileContents({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path,
                  message,
                  content: encoded,
                  branch: 'feature/auth-gate'
                });
              }
            }

            // 1) Create auth.js
            await createOrUpdate('src/routes/auth.js', authContent, 'Add src/routes/auth.js (implement auth check endpoint)');

            // 2) Update server.js: prepend import if missing and insert app.use line before error handler
            const { data: serverData } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: serverPath,
              ref: 'main'
            });
            const serverText = Buffer.from(serverData.content, serverData.encoding).toString();
            let modified = serverText;

            if (!/import\s+authRouter\s+from\s+['"]\.\/src\/routes\/auth\.js['"]/.test(modified)) {
              modified = "import authRouter from './src/routes/auth.js';\n" + modified;
            }

            if (!/app\.use\(\s*['\"]\/api\/auth['\"]/.test(modified)) {
              // insert app.use before error handler middleware
              const errHandlerRegex = /app\.use\(\(err,\s*req,\s*res,\s*next\)\s*=>\s*\{/;
              if (errHandlerRegex.test(modified)) {
                modified = modified.replace(errHandlerRegex, "app.use('/api/auth', authRouter);\n\napp.use((err, req, res, next) => {");
              } else {
                // fallback: append near end
                modified = modified + "\n\n// NOTE: auth route insertion fallback\napp.use('/api/auth', authRouter);\n";
              }
            }

            await createOrUpdate(serverPath, modified, 'Register auth route in server.js');

            // 3) Update package.json to include ethers
            const { data: pkgData } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: pkgPath,
              ref: 'main'
            });
            const pkgText = Buffer.from(pkgData.content, pkgData.encoding).toString();
            const pkg = JSON.parse(pkgText);
            pkg.dependencies = pkg.dependencies || {};
            if (!pkg.dependencies.ethers) {
              pkg.dependencies.ethers = '^6.9.0';
            }
            await createOrUpdate(pkgPath, JSON.stringify(pkg, null, 2), 'Add ethers dependency to package.json');

            core.info('Files written to branch feature/auth-gate');
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: feature/auth-gate
          base: main
          title: "Add server-side auth route for whitelist token gating"
          body: |
            Add server-side auth route for whitelist token gating

            Što je dodano:
            - src/routes/auth.js: nova ruta /api/auth/check-access (POST + GET). Provjerava tablicu whitelisted_wallets (ili drugo ime prema env var) koristeći SUPABASE_SERVICE_ROLE_KEY server-side i vraća JSON { success, allowed, reason, balance? }.
            - server.js: automatski injektiran import authRouter i registracija app.use('/api/auth', authRouter).
            - package.json: dodana dependency "ethers" za eventualne on-chain provjere.

            IMPORTANT environment variables to set on Render (backend):
            - SUPABASE_URL
            - SUPABASE_SERVICE_ROLE_KEY
            - SUPABASE_WHITELIST_TABLE = whitelisted_wallets
            - SUPABASE_WHITELIST_ADDRESS_COL = wallet_address
            - SUPABASE_WHITELIST_FLAG_COL = active
            - BASE_RPC_URL (optional; for on-chain checks)
            - TOKEN_CONTRACT_ADDRESS + MIN_TOKEN_AMOUNT (optional; when token is deployed)

            Manual test (after redeploy):
            - curl https://<backend-url>/health
            - curl -X POST https://<backend-url>/api/auth/check-access -H "Content-Type: application/json" -d '{"address":"0x..."}'

            Security note:
            - Supabase service_role key is only used server-side in the backend.
            - The action uses the repository's GITHUB_TOKEN to push and open the PR.

            Screenshots/context: user provided Supabase and Vercel screenshots.

            DO NOT MERGE until reviewed and tested.
